/*
__Project Description__
  * USN, Campus Kongsberg
  * Snow-e Autonomous Snow Blower
  * Coverage Path Planning using GPS waypoints generated by BCD
  * Scenario 2: 1 static obstacle with snow

__Version History__
  - Version:      0.5.2
  - Update:       19.05.2020
  - Engineer(s):  V. J. Hansen, D. Kazokas

__Sensors used__
  - Compass:      Navigation
  - GPS:          Generate Zig-Zag path
  - SONAR:
  -
*/


/* Webots libraries */
#include <webots/motor.h>
#include <webots/robot.h>
#include <webots/compass.h>
#include <webots/distance_sensor.h>
#include <webots/gps.h>
#include <webots/lidar.h>

/* C libraries */
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>

/* Macro Definitions */
#define THRESHOLD        900.0
#define TIME_STEP        8
#define NUM_SONAR        8
#define DEFAULT_SPEED    0.1
#define DELTA            0.5
#define SIZE_Z           9
#define MAXCHAR          1000
#define TURN_COEFFICIENT 0.01

enum FSM { NORMAL, OBSTACLE_R, OBSTACLE_L, DONE };

/* Enum Data Types */
enum SONAR_Sensors { SFL, SBL, SBR, SFR, SFM, SFML, SFMR, SBM };
enum SIDES { LEFT, RIGHT, MIDDLE };
enum XZComponents { X, Y, Z };

/* Webots Sensors */
static WbDeviceTag l_motor, r_motor;
static WbDeviceTag sonar[NUM_SONAR];
static WbDeviceTag compass;
static WbDeviceTag gps;
static WbDeviceTag lidar;


/* Alternative Naming */
typedef struct _Vector {
  double X_v;
  double Z_u;
} Vector;


char *xfile = "../../Coverage_Planning/files/x_waypoints.txt";
char *zfile = "../../Coverage_Planning/files/z_waypoints.txt";

static Vector targets[100];
static int num_points = 0;
static double saved_pos = 0;
static double X_target[MAXCHAR] = {0};
static double Z_target[MAXCHAR] = {0};
double sonar_val[NUM_SONAR] = {0.0, 0.0, 0.0};
double distance = 0.0;
int state = NORMAL;
static int target_index = 1; // = 0 is where we start
double gps_val[2] = {0.0, 0.0};
double start_gps_pos[3] = {0.0, 0.0, 0.0};
int target_points = 2*(SIZE_Z/DELTA);

// - read .txt-file
void read_file(char *filename, double *arr_get) {
  FILE *fp;
  char str[MAXCHAR];
  fp = fopen(filename, "r");
  if (fp == NULL){
      printf("Could not open file %s",filename);
  }
  int i = 0;
  while (fgets(str, MAXCHAR, fp) != NULL) {
    char *token = strtok(str, ",");
    while (token != NULL) {
      i++;
      arr_get[i] = atof(token);
      num_points = i;
      token = strtok(NULL, ",");
    }
  }
  fclose(fp);
}

/* Euclidean Norm */
static double norm(const Vector *vec) {
  return sqrt(vec->Z_u*vec->Z_u + vec->X_v*vec->X_v);
}

// v = v/||v||
static void normalize(Vector *vec) {
  double n = norm(vec);
  vec->Z_u /= n;
  vec->X_v /= n;
}


// new vector = vector 1 - vector 2
static void minus(Vector *diff, const Vector *trgt, const Vector *gpsPos) {
  diff->X_v = trgt->X_v - gpsPos->X_v;
  diff->Z_u = trgt->Z_u - gpsPos->Z_u;
}

/*__________ Initialize Function __________*/
static void initialize(void) {
  //..... Boot Message .....
  printf("\nInitializing Snow-e Robot...\n");

  //..... Enable Motors .....
  l_motor = wb_robot_get_device("left motor");
  r_motor = wb_robot_get_device("right motor");
  wb_motor_set_position(l_motor, INFINITY);
  wb_motor_set_position(r_motor, INFINITY);
  wb_motor_set_velocity(l_motor, 0.0);
  wb_motor_set_velocity(r_motor, 0.0);

  //..... Enable Sonar .....
  char sonar_names[NUM_SONAR][10] = {
    "Sonar_FL", "Sonar_BL", "Sonar_BR", "Sonar_FR",
    "Sonar_FM", "Sonar_FML", "Sonar_FMR", "Sonar_BM" };
  
  
  for (int i = 0; i < NUM_SONAR; i++) {
    sonar[i] = wb_robot_get_device(sonar_names[i]);
    wb_distance_sensor_enable(sonar[i], TIME_STEP);
  }
  
    //..... Enable LIDAR .....
 /*  lidar = wb_robot_get_device("lidar");
   wb_lidar_enable(lidar, TIME_STEP);
   wb_lidar_enable_point_cloud(lidar);
*/
  //..... Enable Compass .....
  compass = wb_robot_get_device("compass");
  wb_compass_enable(compass, TIME_STEP);

  //..... Enable GPS .....
  gps = wb_robot_get_device("gps");
  wb_gps_enable(gps, TIME_STEP);
}
/*_________________________________________*/


/*__________ Autopilot Function __________*/
static int drive_autopilot(void) {
  double speed[2]       = {0.0, 0.0};
  double current_time   = wb_robot_get_time();
  const double *north2D = wb_compass_get_values(compass);
  double theta          = atan2(north2D[X], north2D[Z]) * (180/M_PI); // angle (in degrees) between x and z-axis
  const double *gps_pos = wb_gps_get_values(gps);
  
  //https://github.com/cyberbotics/webots/blob/69202baee3c0974f69f0e72d3412d19ed69feaad/tests/api/controllers/lidar_point_cloud/lidar_point_cloud.c
  //const WbLidarPoint *gt_point = wb_lidar_get_point_cloud(lidar);
  
  for (int i = 0; i < NUM_SONAR; i++) {
    sonar_val[i] = wb_distance_sensor_get_value(sonar[i]);
  }

  Vector north = {north2D[X], north2D[Z]};
  Vector front = {north.X_v, -north.Z_u};
  Vector curr_gps_pos = {gps_pos[X], gps_pos[Z]};
  Vector dir;
  minus(&dir, &targets[target_index], &curr_gps_pos);
  distance = norm(&dir);
  normalize(&dir);

  double beta_f = atan2(front.X_v, front.Z_u) * (180/M_PI); // compute current angle
  double beta_t = atan2(dir.X_v, dir.Z_u) * (180/M_PI); // compute target angle
  double e_beta = beta_t - beta_f; // error between target and actual position

  // legg til derivat- og integral-ledd.

  // used for calibration
  if (fmod(current_time, 10) == 0.0) {
    printf("(s: %.4g)\n",  targets[target_index-1].Z_u);
    printf("(s: %.4g)\n",  targets[target_index].Z_u);
  }
  // how close the snow blower should approach the waypoints
  if (distance <= 0.2) {
    target_index++;
  }
  else if (target_index == num_points) {
    target_index = 1;
  }
  switch (state) {
    //..... GET the x-direction (North/South) the robot is pointing to initially .....
    case NORMAL:
      speed[LEFT]  = DEFAULT_SPEED - TURN_COEFFICIENT * e_beta;
      speed[RIGHT] = DEFAULT_SPEED + TURN_COEFFICIENT * e_beta;
      if (sonar_val[SFM] > THRESHOLD || sonar_val[SFML] > THRESHOLD || sonar_val[SFMR] > THRESHOLD) {
        state = OBSTACLE_R;
        saved_pos = gps_pos[Z];
      }
      
     /* else if (sonar_val[SFL] > THRESHOLD && sonar_val[SFM] > THRESHOLD) {
        state = OBSTACLE_R;
        saved_pos = gps_pos[Z];
      }*/
      break;

    case OBSTACLE_R:
      if (targets[target_index-1].Z_u >= targets[target_index].Z_u) {
        speed[LEFT]  = DEFAULT_SPEED;
        speed[RIGHT] = -DEFAULT_SPEED;
        if (theta >= -0.5 && theta <= 0.5) {
          speed[LEFT]  = DEFAULT_SPEED;
          speed[RIGHT] = DEFAULT_SPEED;
          if (sonar_val[SFR]  < THRESHOLD && sonar_val[SFL]  < THRESHOLD &&
              sonar_val[SBR]  < THRESHOLD && sonar_val[SBL]  < THRESHOLD &&
              sonar_val[SFM]  < THRESHOLD && sonar_val[SBM]  < THRESHOLD && 
              sonar_val[SFML] < THRESHOLD && sonar_val[SFMR] < THRESHOLD && 
              fabs(gps_pos[Z]) >= fabs(saved_pos)+2*DELTA) {
           state = NORMAL;
          }
        }
      }
      else if (targets[target_index-1].Z_u <= targets[target_index].Z_u) { // check if we are close to boundary of parking lot.
        speed[LEFT]  = -DEFAULT_SPEED;
        speed[RIGHT] = DEFAULT_SPEED;
        if (fabs(theta) >= 179.0 && fabs(theta) <= 181.0) {
          speed[LEFT]  = DEFAULT_SPEED;
          speed[RIGHT] = DEFAULT_SPEED;
          if (sonar_val[SFR]  < THRESHOLD && sonar_val[SFL]  < THRESHOLD &&
              sonar_val[SBR]  < THRESHOLD && sonar_val[SBL]  < THRESHOLD &&
              sonar_val[SFM]  < THRESHOLD && sonar_val[SBM]  < THRESHOLD && 
              sonar_val[SFML] < THRESHOLD && sonar_val[SFMR] < THRESHOLD && 
              fabs(gps_pos[Z]) <= fabs(saved_pos)-2*DELTA) {
           state = NORMAL;
          }
        }
      }
      break;
      
      
   /* case OBSTACLE_L:
      speed[LEFT]  = -DEFAULT_SPEED;
      speed[RIGHT] = DEFAULT_SPEED;
      if (fabs(theta) >= 179.0 && fabs(theta) <= 181.0) {
         speed[LEFT]  = DEFAULT_SPEED;
         speed[RIGHT] = DEFAULT_SPEED;
         if (sonar_val[SFR] < THRESHOLD && sonar_val[SFL] < THRESHOLD &&
             sonar_val[SBR] < THRESHOLD && sonar_val[SBL] < THRESHOLD &&
             sonar_val[SFM] < THRESHOLD && sonar_val[SBM] < THRESHOLD  ) {
           state = NORMAL;
         }
      }
      break;*/
    
    case DONE:
      speed[LEFT]  = 0.0;
      speed[RIGHT] = 0.0;
      break;
    default:
      break;
    }

  //..... Set Speed .....
  wb_motor_set_velocity(l_motor, speed[LEFT]);
  wb_motor_set_velocity(r_motor, speed[RIGHT]);
  return TIME_STEP;
}
/*_________________________________________*/

/*__________ Main Function __________*/
int main(int argc, char **argv) {
  wb_robot_init();
  initialize();
  read_file(xfile, X_target);
  read_file(zfile, Z_target);

  // fill target-vector with X and Z way points
  for (int i=0, j=1; i<num_points; i++, j++) {
    targets[i].X_v = X_target[i];
    targets[i].Z_u = Z_target[j];
  }
  printf("\nStarting Snow-e in Autopilot Mode...\n\n");
  while (wb_robot_step(TIME_STEP) != -1) {
    drive_autopilot();
  };
  wb_robot_cleanup();
  return 0;
}
