/*
__Project Description__
  * USN, Campus Kongsberg
  * Snow-e Autonomous Snow Blower
  * Coverage Path Planning using GPS waypoints generated by BCD
  * Scenario 1: No obstacles

__Version History__
  - Version:      1.0
  - Update:       19.05.2020
  - Engineer(s):  V. J. Hansen, D. Kazokas

__Sensors used__
  - Compass:      Navigation
  - GPS:          Generate Zig-Zag path
  - SONAR:
  - LIDAR:
  -
*/


/* Webots libraries */
#include <webots/motor.h>
#include <webots/robot.h>
#include <webots/compass.h>
#include <webots/distance_sensor.h>
#include <webots/gps.h>
#include <webots/lidar.h>

/* C libraries */
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>

/* Macro Definitions */
#define THRESHOLD        900.0
#define TIME_STEP        8
#define NUM_SONAR        3
#define DEFAULT_SPEED    0.5 // m/s
#define MAX_TURN_SPEED   0.7 // m/s
#define delta            0.3
#define size_x           5
#define size_z           10
#define MAXCHAR          1000
#define TURN_COEFFICIENT 0.01


/* Enum Data Types */
enum SONAR_Sensors { Sonar_L, Sonar_R, Sonar_M };
enum SIDES { LEFT, RIGHT, MIDDLE };
enum XZComponents { X, Y, Z };

/* Webots Sensors */
static WbDeviceTag l_motor, r_motor;
static WbDeviceTag sonar[NUM_SONAR];
static WbDeviceTag compass;
static WbDeviceTag gps;
static WbDeviceTag lidar;

/* Alternative Naming */
typedef struct _Vector {
  double X_v;
  double Z_u;
} Vector;

char *xfile = "../../Coverage_Planning/files/x_waypoints.txt";
char *zfile = "../../Coverage_Planning/files/z_waypoints.txt";

static Vector targets[100];
static int num_points = 0;
static double X_target[MAXCHAR] = {0};
static double Z_target[MAXCHAR] = {0};
double sonar_val[NUM_SONAR] = {0.0, 0.0, 0.0};
double distance = 0.0;
static int target_index = 1; // = 0 is where we start
double gps_val[2] = {0.0, 0.0};
double start_gps_pos[3] = {0.0, 0.0, 0.0};
int target_points = 2*(size_z/delta);

// - read .txt-file
void read_file(char *filename, double *arr_get) {
  FILE *fp;
  char str[MAXCHAR];
  fp = fopen(filename, "r");
  if (fp == NULL){
      printf("Could not open file %s",filename);
  }
  int i = 0;
  while (fgets(str, MAXCHAR, fp) != NULL) {
    char *token = strtok(str, ",");
    while (token != NULL) {
      i++;
      arr_get[i] = atof(token);
      num_points = i;
      token = strtok(NULL, ",");
    }
  }
  fclose(fp);
}

/* Euclidean Norm */
static double norm(const Vector *vec) {
  return sqrt(vec->Z_u*vec->Z_u + vec->X_v*vec->X_v);
}

// v = v/||v||
static void normalize(Vector *vec) {
  double n = norm(vec);
  vec->Z_u /= n;
  vec->X_v /= n;
}


// new vector = vector 1 - vector 2
static void minus(Vector *diff, const Vector *trgt, const Vector *gpsPos) {
  diff->X_v = trgt->X_v - gpsPos->X_v;
  diff->Z_u = trgt->Z_u - gpsPos->Z_u;
}

/*__________ Initialize Function __________*/
static void initialize(void) {
  //..... Boot Message .....
  printf("\nInitializing Snow-e Robot...\n");

  //..... Enable Motors .....
  l_motor = wb_robot_get_device("left motor");
  r_motor = wb_robot_get_device("right motor");
  wb_motor_set_position(l_motor, INFINITY);
  wb_motor_set_position(r_motor, INFINITY);
  wb_motor_set_velocity(l_motor, 0.0);
  wb_motor_set_velocity(r_motor, 0.0);

  //..... Enable Sonar .....
  char sonar_names[NUM_SONAR][8] = {"Sonar_L", "Sonar_R", "Sonar_M"};
  for (int i = 0; i < NUM_SONAR; i++) {
    sonar[i] = wb_robot_get_device(sonar_names[i]);
    wb_distance_sensor_enable(sonar[i], TIME_STEP);
  }

  //..... Enable Compass .....
  compass = wb_robot_get_device("compass");
  wb_compass_enable(compass, TIME_STEP);

  //..... Enable GPS .....
  gps = wb_robot_get_device("gps");
  wb_gps_enable(gps, TIME_STEP);
}
/*_________________________________________*/


/*__________ Autopilot Function __________*/
static int drive_autopilot(void) {
  float Kp = 0.1;
  float Ki = 0.01;
  static float integral = 0;
  float current_speed_l = wb_motor_get_velocity(l_motor);
  float current_speed_r = wb_motor_get_velocity(r_motor);
  
  double speed[2]       = {0.0, 0.0};
  double current_time   = wb_robot_get_time();
  const double *north2D = wb_compass_get_values(compass);
  //double theta          = atan2(north2D[X], north2D[Z]) * (180/M_PI); // angle (in degrees) between x and z-axis
  const double *gps_pos = wb_gps_get_values(gps);

/*for (int i = 0; i < NUM_SONAR; i++) {
    sonar_val[i] = wb_distance_sensor_get_value(sonar[i]);
  }*/

  Vector north = {north2D[X], north2D[Z]};
  Vector front = {north.X_v, -north.Z_u};
  Vector curr_gps_pos = {gps_pos[X], gps_pos[Z]};
  Vector dir;
  minus(&dir, &targets[target_index], &curr_gps_pos);
  distance = norm(&dir);
  normalize(&dir);

  float beta_c = atan2(front.X_v, front.Z_u) * (180/M_PI); // compute current angle
  float beta_t = atan2(dir.X_v, dir.Z_u) * (180/M_PI); // compute target angle
  float beta_e = (beta_t - beta_c) * TURN_COEFFICIENT; // error between target and actual position
  
  // --------------- Speed Constraints ---------------
  if(current_speed_l >  MAX_TURN_SPEED){current_speed_l =  MAX_TURN_SPEED;}
  if(current_speed_r >  MAX_TURN_SPEED){current_speed_r =  MAX_TURN_SPEED;}
  if(current_speed_l < -MAX_TURN_SPEED){current_speed_l = -MAX_TURN_SPEED;}
  if(current_speed_r < -MAX_TURN_SPEED){current_speed_r = -MAX_TURN_SPEED;}

  // --------------- Calculate PID ---------------
  float speed_abs = ((fabs(current_speed_l)+fabs(current_speed_r))/2); // Calculate mean of speed
  float error = (DEFAULT_SPEED - speed_abs); // Check diviation from desired speed
  integral = integral + error;
  float PID = Kp*error + Ki*integral;
  if (PID < 0) {PID = 0;}
  if (distance < 2) {PID = 0.35;} // Reduce speed to 0.35m/s 
  
  //printf("(error: %f, i: %f, pid: %f, speed_abs: %f, speed_l: %f, speed_r: %f, beta_e: %f)\n", error, integral, PID, speed_abs, current_speed_l, current_speed_r, beta_e);
  // --------------- End PID ---------------
  
  
  // used for calibration
  //printf("distance: %f\n", distance);
  if (fmod(current_time, 10) == 0.0) {
   // printf("(t: %.4g, %.4g)\n", X_target[target_index], Z_target[target_index]);
   // printf("(t: %.4g, %.4g)\n", gps_pos[X], gps_pos[Z]);
  }
  // how close the snow blower should approach the waypoints
  if (distance <= 0.1) {
    printf("Reached Waypoint: %d\n",target_index);
    target_index++;
    integral = 0; // Reset PID integral part when Waypoint is reached
  }
  else if (target_index == num_points) {
    target_index = 1; // go back to start.
    // should stop simulation
  }

  else {
    speed[LEFT]  = PID - beta_e;
    speed[RIGHT] = PID + beta_e;
  }

  //..... Set Speed .....
  wb_motor_set_velocity(l_motor, speed[LEFT]);
  wb_motor_set_velocity(r_motor, speed[RIGHT]);

  return TIME_STEP;
}
/*_________________________________________*/

/*__________ Main Function __________*/
int main(int argc, char **argv) {
  wb_robot_init();
  initialize();
  read_file(xfile, X_target);
  read_file(zfile, Z_target);

  // fill target-vector with X and Z way points
  for (int i=0, j=1; i<num_points; i++, j++) {
    targets[i].X_v = X_target[i];
    targets[i].Z_u = Z_target[j];
  }
  printf("\nStarting Snow-e in Autopilot Mode...\n\n");
  while (wb_robot_step(TIME_STEP) != -1) {
    drive_autopilot();
  };
  wb_robot_cleanup();
  return 0;
}
